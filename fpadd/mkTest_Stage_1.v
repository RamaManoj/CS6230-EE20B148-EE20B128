//
// Generated by Bluespec Compiler, version 2021.12.1 (build fd501401)
//
// On Wed Dec 13 13:54:57 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTest_Stage_1(CLK,
		      RST_N);
  input  CLK;
  input  RST_N;

  // register i
  reg [31 : 0] i;
  wire [31 : 0] i$D_IN;
  wire i$EN;

  // ports of submodule dut
  reg [63 : 0] dut$feed_input_1, dut$feed_input_2;
  wire dut$EN_feed, dut$RDY_feed, dut$feed_is_valid;

  // rule scheduling signals
  wire WILL_FIRE_RL_test;

  // remaining internal signals
  reg [63 : 0] CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1;
  wire i_SLT_14___d10, i_SLT_18___d3;

  // submodule dut
  mkStage_1 dut(.CLK(CLK),
		.RST_N(RST_N),
		.feed_input_1(dut$feed_input_1),
		.feed_input_2(dut$feed_input_2),
		.feed_is_valid(dut$feed_is_valid),
		.EN_feed(dut$EN_feed),
		.RDY_feed(dut$RDY_feed));

  // rule RL_test
  assign WILL_FIRE_RL_test = dut$RDY_feed && i_SLT_18___d3 && !i[31] ;

  // register i
  assign i$D_IN = i + 32'd1 ;
  assign i$EN = WILL_FIRE_RL_test ;

  // submodule dut
  always@(i)
  begin
    case (i)
      32'd0: dut$feed_input_1 = 64'h405EC00000000000;
      32'd1: dut$feed_input_1 = 64'hC049000000000000;
      32'd2: dut$feed_input_1 = 64'hC034000000000000;
      32'd3: dut$feed_input_1 = 64'h408F3A7AE147AE14;
      32'd4, 32'd8: dut$feed_input_1 = 64'h7FE0000000000001;
      32'd5, 32'd9: dut$feed_input_1 = 64'hFFE0000000000001;
      32'd6: dut$feed_input_1 = 64'hFFF9000000000000;
      32'd7: dut$feed_input_1 = 64'hFFF0000000000000;
      32'd10: dut$feed_input_1 = 64'h4480F0CF064DD592;
      32'd11: dut$feed_input_1 = 64'h000FFFFFFFFFFFFF;
      32'd12: dut$feed_input_1 = 64'h0000000000000001;
      32'd13: dut$feed_input_1 = 64'h0010000000000001;
      default: dut$feed_input_1 =
		   64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  always@(i)
  begin
    case (i)
      32'd0: dut$feed_input_2 = 64'h405EC00000000000;
      32'd1: dut$feed_input_2 = 64'hC049000000000000;
      32'd2: dut$feed_input_2 = 64'h403E000000000000;
      32'd3: dut$feed_input_2 = 64'h4038B0A3D70A3D71;
      32'd4, 32'd8: dut$feed_input_2 = 64'h7FE0000000000001;
      32'd5: dut$feed_input_2 = 64'h8000000000000000;
      32'd6, 32'd7: dut$feed_input_2 = 64'hD559000000000000;
      32'd9: dut$feed_input_2 = 64'hFFE0000000000001;
      32'd10: dut$feed_input_2 = 64'h45208B2A2C280291;
      32'd11: dut$feed_input_2 = 64'h000FFFFFFFFFFFFF;
      32'd12: dut$feed_input_2 = 64'h0000000000000001;
      32'd13: dut$feed_input_2 = 64'h8010000000000000;
      default: dut$feed_input_2 =
		   64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign dut$feed_is_valid = 1'd1 ;
  assign dut$EN_feed = WILL_FIRE_RL_test && i_SLT_14___d10 ;

  // remaining internal signals
  assign i_SLT_14___d10 = (i ^ 32'h80000000) < 32'h8000000E ;
  assign i_SLT_18___d3 = (i ^ 32'h80000000) < 32'h80000012 ;
  always@(i)
  begin
    case (i)
      32'd0:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'h406EC00000000000;
      32'd1:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'hC059000000000000;
      32'd2:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'h4024000000000000;
      32'd3:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'h408FFFFFFFFFFFFF;
      32'd4, 32'd8:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'h7FF0000000000000;
      32'd5:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'hFFE0000000000001;
      32'd6:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'h7FFFFFFFFFFFFFFF;
      32'd7, 32'd9:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'hFFF0000000000000;
      32'd10:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'h45208F665FE99606;
      32'd11:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'h001FFFFFFFFFFFFE;
      32'd12:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'h0000000000000002;
      32'd13:
	  CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
	      64'h0000000000000001;
      default: CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1 =
		   64'hAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        i <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (i$EN) i <= `BSV_ASSIGNMENT_DELAY i$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    i = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_test)
	$display("======================================\nClock Cycle:%d\n",
		 $signed(i + 32'd1));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_test && i_SLT_14___d10)
	$display("Feeding inputs %b %b...",
		 dut$feed_input_1,
		 dut$feed_input_2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_test && i_SLT_14___d10)
	$display("Expected final output = %b",
		 CASE_i_0_0x406EC00000000000_1_0xC0590000000000_ETC__q1);
    if (RST_N != `BSV_RESET_VALUE) if (!i_SLT_18___d3) $finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mkTest_Stage_1

